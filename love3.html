<!DOCTYPE html>
<html lang="ar">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>اسراء قرة عيني — 3D ❤️</title>
<style>
  html, body { height: 100%; margin: 0; background: radial-gradient(ellipse at bottom, #101622 0%, #06070b 100%); overflow: hidden; }
  #app { position: fixed; inset: 0; }
  .overlay {
    position: fixed; inset: 0; display: flex; align-items: center; justify-content: center;
    pointer-events: none;
  }
  .msg {
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    color: #fff; text-align: center; direction: rtl;
    text-shadow: 0 0 12px #fff, 0 0 24px #ff4d6d, 0 0 48px #ff4d6d;
    animation: glow 3s ease-in-out infinite alternate;
  }
  .msg h1 { margin: 0; font-size: clamp(28px, 7vw, 64px); }
  .msg p  { margin: .3em 0 0; font-size: clamp(16px, 4vw, 24px); opacity:.9 }
  @keyframes glow {
    from { text-shadow: 0 0 8px #fff, 0 0 16px #ff6b8a; }
    to   { text-shadow: 0 0 18px #fff, 0 0 36px #ff4d6d, 0 0 60px #ff4d6d; }
  }
  .hint {
    position: fixed; bottom: 14px; left: 50%; transform: translateX(-50%);
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    color:#ffd9e2; opacity:.85; font-size: 14px; pointer-events:none
  }
</style>
</head>
<body>
<div id="app"></div>

<div class="overlay">
  <div class="msg">
    <!-- <h1>اسراء قرة عيني</h1> -->
  </div>
</div>
<div class="hint">اسحبي لتحريك المشهد • كبّري بإصابعك</div>

<!-- Three.js (no build tools needed) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.125.0/build/three.min.js"></script>
<!-- <script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script> -->
<script src="https://cdn.jsdelivr.net/npm/three@0.125.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.125.0/examples/jsm/loaders/FontLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.125.0/examples/jsm/geometries/TextGeometry.js"></script>

<script>
(() => {
  const container = document.getElementById('app');

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  container.appendChild(renderer.domElement);

  const scene = new THREE.Scene();

  // Camera
  const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 200);
  camera.position.set(0, 0.6, 3.2);

  // Controls (touch-friendly)
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.enablePan = false;
  controls.minDistance = 2;
  controls.maxDistance = 6;
  controls.autoRotate = true;
  controls.autoRotateSpeed = 0.6;

  // Lights
  const ambient = new THREE.AmbientLight(0xffb6c1, 0.6);
  scene.add(ambient);
  const dir = new THREE.DirectionalLight(0xffffff, 0.9);
  dir.position.set(3, 4, 2);
  scene.add(dir);


// Add multiple 3D texts
const loader = new THREE.FontLoader();
loader.load('https://cdn.jsdelivr.net/npm/three@0.150.1/examples/fonts/helvetiker_regular.typeface.json',
    function (font) {
        const phrases = [
            "Love Forever",
            "You Are My Joy",
            "Together Always",
            "Esraa"
        ];

        // Create a pivot at the heart's center
        const pivot = new THREE.Object3D();
        scene.add(pivot);

        phrases.forEach((text, index) => {
            const textGeometry = new THREE.TextGeometry(text, {
                font: font,
                size: 5,
                height: 1,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 0.5,
                bevelSize: 0.2,
                bevelSegments: 3
            });

            const textMaterial = new THREE.MeshPhongMaterial({ color: 0xff69b4 });
            const textMesh = new THREE.Mesh(textGeometry, textMaterial);

            // Place texts around the heart in a circle
            const angle = (index / phrases.length) * Math.PI * 2;
            const radius = 20; // distance from heart
            textMesh.position.set(
                Math.cos(angle) * radius,
                -7*Math.cos(angle*2),              // slightly above heart center
                Math.sin(angle) * radius
            );

            // Make text face outward
            textMesh.lookAt(0, 5, 0);

            pivot.add(textMesh);
        });
    }
);

  // 3D Heart — made from a 2D heart shape extruded
  function makeHeartMesh() {
    const heartShape = new THREE.Shape();
    const x = 0, y = 0;
    heartShape.moveTo(x + 0, y + 0.5);
    heartShape.bezierCurveTo(x + 0, y + 0.8, x - 0.5, y + 0.8, x - 0.5, y + 0.5);
    heartShape.bezierCurveTo(x - 0.5, y + 0.2, x - 0.1, y + 0.05, x + 0, y - 0.2);
    heartShape.bezierCurveTo(x + 0.1, y + 0.05, x + 0.5, y + 0.2, x + 0.5, y + 0.5);
    heartShape.bezierCurveTo(x + 0.5, y + 0.8, x + 0, y + 0.8, x + 0, y + 0.5);

    const geo = new THREE.ExtrudeGeometry(heartShape, {
      depth: 0.5, bevelEnabled: true, bevelSegments: 24, steps: 2, bevelSize: 0.05, bevelThickness: 0.05,
      curveSegments: 64
    });
    geo.center();

    const mat = new THREE.MeshPhysicalMaterial({
      color: 0xff4d6d,
      metalness: 0.1,
      roughness: 0.3,
      transmission: 0.0, // not glass; keep it solid
      clearcoat: 1.0,
      clearcoatRoughness: 0.15,
      emissive: 0xff2a50,
      emissiveIntensity: 0.35
    });

    const mesh = new THREE.Mesh(geo, mat);
    mesh.castShadow = false;
    mesh.receiveShadow = false;
    mesh.scale.set(1.2, 1.2, 1.2);
    return mesh;
  }

  const heart = makeHeartMesh();
  scene.add(heart);

  // Soft bloom-like glow via sprite halo
  const haloTex = (function makeHaloTexture() {
    const size = 256, c = document.createElement('canvas');
    c.width = c.height = size;
    const ctx = c.getContext('2d');
    const grd = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
    grd.addColorStop(0, 'rgba(255, 120, 150, 0.8)');
    grd.addColorStop(1, 'rgba(255, 120, 150, 0)');
    ctx.fillStyle = grd;
    ctx.beginPath(); ctx.arc(size/2, size/2, size/2, 0, Math.PI*2); ctx.fill();
    const tex = new THREE.CanvasTexture(c);
    tex.colorSpace = THREE.SRGBColorSpace;
    return tex;
  })();

  const halo = new THREE.Sprite(new THREE.SpriteMaterial({ map: haloTex, depthWrite: false, depthTest: true }));
  halo.scale.set(3.5, 3.5, 1);
  scene.add(halo);

  // Starfield (lightweight particles)
  const stars = (() => {
    const starGeo = new THREE.BufferGeometry();
    const count = 800;
    const positions = new Float32Array(count * 3);
    for (let i = 0; i < count; i++) {
      const r = 30 * Math.pow(Math.random(), 0.6); // cluster a bit near center
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      positions[i*3+0] = r * Math.sin(phi) * Math.cos(theta);
      positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
      positions[i*3+2] = r * Math.cos(phi);
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const starMat = new THREE.PointsMaterial({ size: 0.06, color: 0xffffff, transparent: true, opacity: 0.9 });
    const pts = new THREE.Points(starGeo, starMat);
    scene.add(pts);
    return pts;
  })();
// Heart-shaped starfield
const heartStarfield = (() => {
  const count = 200; // number of hearts
  const hearts = new THREE.Group();
  scene.add(hearts);

  // Proper heart shape
  const heartShape = new THREE.Shape();
  heartShape.moveTo(0, 0);
  heartShape.bezierCurveTo(0, 0.6, -0.5, 1, -1, 0.5);
  heartShape.bezierCurveTo(-1.5, 0, -1, -0.5, 0, -1);
  heartShape.bezierCurveTo(1, -0.5, 1.5, 0, 1, 0.5);
  heartShape.bezierCurveTo(0.5, 1, 0, 0.6, 0, 0);

  const geometry = new THREE.ExtrudeGeometry(heartShape, { 
    depth: 0.05, 
    bevelEnabled: true, 
    bevelThickness: 0.02, 
    bevelSize: 0.02, 
    bevelSegments: 2 
  });
  const material = new THREE.MeshPhongMaterial({ color: 0xff69b4 });

  for (let i = 0; i < count; i++) {
    const mesh = new THREE.Mesh(geometry, material);

    // Random position in spherical space
    const r = 30 * Math.pow(Math.random(), 0.6);
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(2 * Math.random() - 1);

    mesh.position.set(
      r * Math.sin(phi) * Math.cos(theta),
      r * Math.sin(phi) * Math.sin(theta),
      r * Math.cos(phi)
    );

    // Small random rotation
    mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);

    // Scale down to make them tiny
    mesh.scale.set(0.1, 0.1, 0.1);

    hearts.add(mesh);
  }

  return hearts;
})();



  // Heartfield (less dense than stars)
const hearts = (() => {
  const heartGeo = new THREE.BufferGeometry();
  const count = 0; // أقل من النجوم
  const positions = new Float32Array(count * 3);

  for (let i = 0; i < count; i++) {
    const t = Math.random() * Math.PI * 2;   // زاوية عشوائية
    const s = Math.random() * 2 - 1;         // عامل ارتفاع عشوائي

    // معادلة القلب 2D: x = 16 sin^3(t), y = 13 cos(t) - 5 cos(2t) - 2 cos(3t) - cos(4t)
    let x = 16 * Math.pow(Math.sin(t), 3);
    let y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);

    // إضافة تباين في z ليصبح القلب 3D
    let z = s * 2;  // سمك القلب

    // Scale down a bit
    positions[i*3+0] = x * 0.6;
    positions[i*3+1] = y * 0.6;
    positions[i*3+2] = z * 0.6;
  }

  heartGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));

  const heartMat = new THREE.PointsMaterial({ 
    size: 0.2, 
    color: 0xff69b4, // وردي
    transparent: true, 
    opacity: 0.9 
  });

  const pts = new THREE.Points(heartGeo, heartMat);
  scene.add(pts);

  return pts;
})();

  // Heart sparkle burst
  const bursts = [];
  function spawnBurst(origin) {
    const n = 20;
    for (let i = 0; i < n; i++) {
      const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: haloTex, color: 0xff4d6d, transparent: true, opacity: 1 }));
      sprite.position.copy(origin);
      const s = 0.12 + Math.random()*0.18;
      sprite.scale.set(s, s, 1);
      scene.add(sprite);
      const dir = new THREE.Vector3(
        (Math.random()-0.5),
        (Math.random()-0.3),
        (Math.random()-0.5)
      ).normalize().multiplyScalar(0.015 + Math.random()*0.035);
      bursts.push({ sprite, vel: dir, life: 1.2 });
    }
  }

  // Raycaster for clicking the heart
  const raycaster = new THREE.Raycaster();
  const pointer = new THREE.Vector2();
  function onTap(x, y) {
    pointer.x =  (x / window.innerWidth)  * 2 - 1;
    pointer.y = -(y / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(pointer, camera);
    const hit = raycaster.intersectObject(heart, true);
    if (hit.length) {
      // Pulse + color flash
      heart.scale.set(1.45, 1.45, 1.45);
      heart.material.emissiveIntensity = 0.75;
      spawnBurst(hit[0].point.clone());
      setTimeout(() => {
        heart.scale.set(1.2, 1.2, 1.2);
        heart.material.emissiveIntensity = 0.35;
      }, 220);
    }
  }

  // Mouse/touch events
  renderer.domElement.addEventListener('click', e => onTap(e.clientX, e.clientY));
  renderer.domElement.addEventListener('touchstart', e => {
    const t = e.touches[0];
    onTap(t.clientX, t.clientY);
  }, { passive: true });

    // Your chosen colors (Hex or RGB)
    const skyColors = [
    new THREE.Color(0x000), // dark blue
    new THREE.Color(0x2b2d4a), // dark blue
    new THREE.Color(0x322264), // purple
    new THREE.Color(0x435718)  // pink
    ];

    const clock = new THREE.Clock();

  // Subtle idle animation
  let t = 0;
  function animate() {
    requestAnimationFrame(animate);
    t += 0.01;
    heart.rotation.y += 0.005;
    heart.rotation.x = Math.sin(t*0.6) * 0.08;
    heart.position.y = Math.sin(t*0.9) * 0.08;
    halo.position.copy(heart.position);

    // update bursts
    for (let i = bursts.length - 1; i >= 0; i--) {
      const b = bursts[i];
      b.sprite.position.add(b.vel);
      b.sprite.material.opacity -= 0.02;
      b.sprite.scale.multiplyScalar(1.01);
      b.life -= 0.02;
      if (b.life <= 0 || b.sprite.material.opacity <= 0) {
        scene.remove(b.sprite);
        bursts.splice(i, 1);
      }
    }
    
    const elapsed = clock.getElapsedTime();
    const duration = 30; // seconds for full cycle
    const t2 = (elapsed / duration) % 1; // value 0→1

    // Determine current segment between colors
    const segment = t2 * skyColors.length;
    const index = Math.floor(segment);
    const nextIndex = (index + 1) % skyColors.length;
    const mix = segment - index;

    // Smoothly interpolate between two colors
    scene.background = skyColors[index].clone().lerp(skyColors[nextIndex], mix);

    controls.update();
    renderer.render(scene, camera);
  }
  animate();

    // Resize handling
    window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    });

    // Example: smoothly cycle colors
    const r = 0.2 + 0.3 * Math.sin(elapsed * 0.1); // between 0.2 and 0.5
    const g = 0.1 + 0.2 * Math.sin(elapsed * 0.12 + 1);
    const b = 0.3 + 0.4 * Math.sin(elapsed * 0.15 + 2);

    scene.background = new THREE.Color(r, g, b);

})();
</script>


<script>
    // ... نفس الكود تبع المشهد والقلب والنجوم ...

</script>


</body>
</html>
